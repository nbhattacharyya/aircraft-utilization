"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RichPropertyType = exports.PropertyScrutinyType = exports.ResourceScrutinyType = exports.isCollectionType = exports.Deprecation = exports.RichAttribute = exports.RichProperty = exports.RichTypedField = void 0;
const sorting_1 = require("../util/sorting");
class RichTypedField {
    constructor(field) {
        this.field = field;
        if (field === undefined) {
            throw new Error('Field is undefined');
        }
    }
    types() {
        var _a;
        return [...((_a = this.field.previousTypes) !== null && _a !== void 0 ? _a : []), this.field.type];
    }
    /**
     * Update the type of this property with a new type
     *
     * Only if it's not in the set of types already.
     */
    updateType(type) {
        const richType = new RichPropertyType(type);
        // Only add this type if we don't already have it. We are only doing comparisons where 'integer' and 'number'
        // are treated the same, for all other types we need strict equality. We used to use 'assignableTo' as a
        // condition, but these types will be rendered in both co- and contravariant positions, and so we really can't
        // do much better than full equality.
        if (this.types().some((t) => richType.equals(t))) {
            // Nothing to do, type is already in there.
            return false;
        }
        // Special case: if the new type is `string` and the old type is `date-time`, we assume this is
        // the same type but we dropped some formatting information. No need to make this a separate type.
        if (type.type === 'string' && this.types().some((t) => t.type === 'date-time')) {
            return false;
        }
        if (!this.field.previousTypes) {
            this.field.previousTypes = [];
        }
        this.field.previousTypes.push(this.field.type);
        this.field.type = type;
        return true;
    }
}
exports.RichTypedField = RichTypedField;
class RichProperty extends RichTypedField {
    constructor(property) {
        super(property);
    }
}
exports.RichProperty = RichProperty;
class RichAttribute extends RichTypedField {
    constructor(attr) {
        super(attr);
    }
}
exports.RichAttribute = RichAttribute;
var Deprecation;
(function (Deprecation) {
    /**
     * Not deprecated
     */
    Deprecation["NONE"] = "NONE";
    /**
     * Warn about use
     */
    Deprecation["WARN"] = "WARN";
    /**
     * Do not emit the value at all
     *
     * (Handle properties that were incorrectly added to the spec)
     */
    Deprecation["IGNORE"] = "IGNORE";
})(Deprecation = exports.Deprecation || (exports.Deprecation = {}));
function isCollectionType(x) {
    return x.type === 'array' || x.type === 'map';
}
exports.isCollectionType = isCollectionType;
/**
 * Mark a resource as a resource that needs additional scrutiy when added, removed or changed
 *
 * Used to mark resources that represent security policies.
 */
var ResourceScrutinyType;
(function (ResourceScrutinyType) {
    /**
     * No additional scrutiny
     */
    ResourceScrutinyType["None"] = "None";
    /**
     * An externally attached policy document to a resource
     *
     * (Common for SQS, SNS, S3, ...)
     */
    ResourceScrutinyType["ResourcePolicyResource"] = "ResourcePolicyResource";
    /**
     * This is an IAM policy on an identity resource
     *
     * (Basically saying: this is AWS::IAM::Policy)
     */
    ResourceScrutinyType["IdentityPolicyResource"] = "IdentityPolicyResource";
    /**
     * This is a Lambda Permission policy
     */
    ResourceScrutinyType["LambdaPermission"] = "LambdaPermission";
    /**
     * An ingress rule object
     */
    ResourceScrutinyType["IngressRuleResource"] = "IngressRuleResource";
    /**
     * A set of egress rules
     */
    ResourceScrutinyType["EgressRuleResource"] = "EgressRuleResource";
    /**
     * AWS::SSO::Assignment
     *
     * IAM Identity Center (formerly known as SSO)
     */
    ResourceScrutinyType["SsoAssignmentResource"] = "SsoAssignmentResource";
    /**
     * AWS::SSO::InstanceAccessControlAttributeConfiguration
     *
     * IAM Identity Center (formerly known as SSO)
     */
    ResourceScrutinyType["SsoInstanceACAConfigResource"] = "SsoInstanceACAConfigResource";
    /**
     * AWS::SSO::PermissionSet
     *
     * IAM Identity Center (formerly known as SSO)
     */
    ResourceScrutinyType["SsoPermissionSet"] = "SsoPermissionSet";
})(ResourceScrutinyType = exports.ResourceScrutinyType || (exports.ResourceScrutinyType = {}));
/**
 * Mark a property as a property that needs additional scrutiny when it changes
 *
 * Used to mark sensitive properties that have security-related implications.
 */
var PropertyScrutinyType;
(function (PropertyScrutinyType) {
    /**
     * No additional scrutiny
     */
    PropertyScrutinyType["None"] = "None";
    /**
     * This is an IAM policy directly on a resource
     */
    PropertyScrutinyType["InlineResourcePolicy"] = "InlineResourcePolicy";
    /**
     * Either an AssumeRolePolicyDocument or a dictionary of policy documents
     */
    PropertyScrutinyType["InlineIdentityPolicies"] = "InlineIdentityPolicies";
    /**
     * A list of managed policies (on an identity resource)
     */
    PropertyScrutinyType["ManagedPolicies"] = "ManagedPolicies";
    /**
     * A set of ingress rules (on a security group)
     */
    PropertyScrutinyType["IngressRules"] = "IngressRules";
    /**
     * A set of egress rules (on a security group)
     */
    PropertyScrutinyType["EgressRules"] = "EgressRules";
})(PropertyScrutinyType = exports.PropertyScrutinyType || (exports.PropertyScrutinyType = {}));
class RichPropertyType {
    constructor(type) {
        this.type = type;
    }
    equals(rhs) {
        switch (this.type.type) {
            case 'integer':
            case 'boolean':
            case 'date-time':
            case 'json':
            case 'null':
            case 'number':
            case 'string':
            case 'tag':
                return rhs.type === this.type.type;
            case 'array':
            case 'map':
                return rhs.type === this.type.type && new RichPropertyType(this.type.element).equals(rhs.element);
            case 'ref':
                return rhs.type === 'ref' && this.type.reference.$ref === rhs.reference.$ref;
            case 'union':
                const lhsKey = this.sortKey();
                const rhsKey = new RichPropertyType(rhs).sortKey();
                return lhsKey.length === rhsKey.length && lhsKey.every((l, i) => l === rhsKey[i]);
        }
    }
    /**
     * Whether the current type is JavaScript-equal to the RHS type
     *
     * Same as normal equality, but consider `integer` and `number` the same types.
     */
    javascriptEquals(rhs) {
        switch (this.type.type) {
            case 'number':
            case 'integer':
                // Widening
                return rhs.type === 'integer' || rhs.type === 'number';
            case 'array':
            case 'map':
                return rhs.type === this.type.type && new RichPropertyType(this.type.element).javascriptEquals(rhs.element);
            case 'union':
                if (rhs.type !== 'union') {
                    return false;
                }
                // Every type in this union needs to be equal one type in RHS
                return this.type.types.every((t1) => rhs.types.some((t2) => new RichPropertyType(t1).javascriptEquals(t2)));
            default:
                // For anything else, need strict equality
                return this.equals(rhs);
        }
    }
    /**
     * Whether the current type is assignable to the RHS type.
     *
     * This is means every type member of the LHS must be present in the RHS type
     */
    assignableTo(rhs) {
        const extractMembers = (type) => (type.type == 'union' ? type.types : [type]);
        const asRichType = (type) => new RichPropertyType(type);
        const rhsMembers = extractMembers(rhs);
        for (const lhsMember of extractMembers(this.type).map(asRichType)) {
            if (!rhsMembers.some((type) => lhsMember.equals(type))) {
                return false;
            }
        }
        return true;
    }
    /**
     * Return a version of this type, but with all type unions in a regularized order
     */
    normalize(db) {
        switch (this.type.type) {
            case 'array':
            case 'map':
                return new RichPropertyType({
                    type: this.type.type,
                    element: new RichPropertyType(this.type.element).normalize(db).type,
                });
            case 'union':
                const types = this.type.types
                    .map((t) => new RichPropertyType(t).normalize(db))
                    .map((t) => [t, t.sortKey(db)]);
                types.sort((0, sorting_1.sortKeyComparator)(([_, sortKey]) => sortKey));
                return new RichPropertyType({
                    type: 'union',
                    types: types.map(([t, _]) => t.type),
                });
            default:
                return this;
        }
    }
    stringify(db, withId = true) {
        switch (this.type.type) {
            case 'integer':
            case 'boolean':
            case 'date-time':
            case 'json':
            case 'null':
            case 'number':
            case 'string':
            case 'tag':
                return this.type.type;
            case 'array':
                return `Array<${new RichPropertyType(this.type.element).stringify(db, withId)}>`;
            case 'map':
                return `Map<string, ${new RichPropertyType(this.type.element).stringify(db, withId)}>`;
            case 'ref':
                const type = db.get('typeDefinition', this.type.reference);
                return withId ? `${type.name}(${this.type.reference.$ref})` : type.name;
            case 'union':
                return this.type.types.map((t) => new RichPropertyType(t).stringify(db, withId)).join(' | ');
        }
    }
    /**
     * Return a sortable key based on this type
     *
     * If a database is given, type definitions will be sorted based on type name,
     * otherwise on identifier
     */
    sortKey(db) {
        var _a, _b;
        switch (this.type.type) {
            case 'integer':
            case 'boolean':
            case 'date-time':
            case 'json':
            case 'null':
            case 'number':
            case 'string':
            case 'tag':
                return ['0', this.type.type];
            case 'array':
            case 'map':
                return ['1', this.type.type, ...new RichPropertyType(this.type.element).sortKey(db)];
            case 'ref':
                return ['2', this.type.type, (_b = (_a = db === null || db === void 0 ? void 0 : db.get('typeDefinition', this.type.reference)) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : this.type.reference.$ref];
            case 'union':
                const typeKeys = this.type.types.map((t) => new RichPropertyType(t).sortKey(db));
                typeKeys.sort((0, sorting_1.sortKeyComparator)((x) => x));
                return ['3', this.type.type, ...typeKeys.flatMap((x) => x)];
        }
    }
}
exports.RichPropertyType = RichPropertyType;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzb3VyY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdHlwZXMvcmVzb3VyY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsNkNBQW9EO0FBdUtwRCxNQUFhLGNBQWM7SUFDekIsWUFBNkIsS0FBK0M7UUFBL0MsVUFBSyxHQUFMLEtBQUssQ0FBMEM7UUFDMUUsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0JBQW9CLENBQUMsQ0FBQztTQUN2QztJQUNILENBQUM7SUFFTSxLQUFLOztRQUNWLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBQSxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsbUNBQUksRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLFVBQVUsQ0FBQyxJQUFrQjtRQUNsQyxNQUFNLFFBQVEsR0FBRyxJQUFJLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTVDLDZHQUE2RztRQUM3Ryx3R0FBd0c7UUFDeEcsOEdBQThHO1FBQzlHLHFDQUFxQztRQUNyQyxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNoRCwyQ0FBMkM7WUFDM0MsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUVELCtGQUErRjtRQUMvRixrR0FBa0c7UUFDbEcsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVEsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLFdBQVcsQ0FBQyxFQUFFO1lBQzlFLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFFRCxJQUFJ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QyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDakYsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFBLDJCQUFpQixFQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMzQyxPQUFPLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMvRDtJQUNILENBQUM7Q0FDRjtBQXRKRCw0Q0FzSkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbnRpdHksIFJlZmVyZW5jZSwgUmVsYXRpb25zaGlwIH0gZnJvbSAnQGNka2xhYnMvdHNrYic7XG5pbXBvcnQgeyBTcGVjRGF0YWJhc2UgfSBmcm9tICcuL2RhdGFiYXNlJztcbmltcG9ydCB7IHNvcnRLZXlDb21wYXJhdG9yIH0gZnJvbSAnLi4vdXRpbC9zb3J0aW5nJztcblxuZXhwb3J0IGludGVyZmFjZSBQYXJ0aXRpb24gZXh0ZW5kcyBFbnRpdHkge1xuICByZWFkb25seSBwYXJ0aXRpb246IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgSGFzUmVnaW9uID0gUmVsYXRpb25zaGlwPFBhcnRpdGlvbiwgUmVnaW9uLCB7IGlzUHJpbWFyeT86IGJvb2xlYW4gfT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmljZSBleHRlbmRzIEVudGl0eSB7XG4gIC8qKlxuICAgKiBUaGUgZnVsbCBuYW1lIG9mIHRoZSBzZXJ2aWNlIGluY2x1ZGluZyB0aGUgZ3JvdXAgcHJlZml4LCBsb3dlcmNhc2VkIGFuZCBoeXBoZW5hdGVkLlxuICAgKlxuICAgKiBFLmcuIGBBV1M6OkR5bmFtb0RCYCAtPiBgYXdzLWR5bmFtb2RiYFxuICAgKlxuICAgKiBAZXhhbXBsZSBhd3MtZHluYW1vZGJcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIE9ubHkgdGhlIHNlcnZpY2UgcGFydCBvZiB0aGUgbmFtZSwgbG93ZXJjYXNlZC5cbiAgICpcbiAgICogRS5nLiBgQVdTOjpEeW5hbW9EQmAgLT4gYGR5bmFtb2RiYFxuICAgKlxuICAgKiBAZXhhbXBsZSBkeW5hbW9kYlxuICAgKi9cbiAgcmVhZG9ubHkgc2hvcnROYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgc2hvcnRuYW1lIG9mIHRoZSBzZXJ2aWNlIGluIGNhcGl0YWxpemVkIGZvcm1cbiAgICpcbiAgICogRS5nLiBgQVdTOjpEeW5hbW9EQmAgLT4gYER5bmFtb0RCYFxuICAgKlxuICAgKiBAZXhhbXBsZSBkeW5hbW9kYlxuICAgKi9cbiAgcmVhZG9ubHkgY2FwaXRhbGl6ZWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBjb21wbGV0ZSBjbG91ZGZvcm1hdGlvbiBzdHlsZSBuYW1lc3BhY2Ugb2YgdGhlIHNlcnZpY2VcbiAgICpcbiAgICogRS5nLiBgQVdTOjpEeW5hbW9EQmBcbiAgICpcbiAgICogQGV4YW1wbGUgZHluYW1vZGJcbiAgICovXG4gIHJlYWRvbmx5IGNsb3VkRm9ybWF0aW9uTmFtZXNwYWNlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVnaW9uIGV4dGVuZHMgRW50aXR5IHtcbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuICByZWFkb25seSBkZXNjcmlwdGlvbj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEb2N1bWVudGF0aW9uIGV4dGVuZHMgRW50aXR5IHtcbiAgcmVhZG9ubHkgbWFya2Rvd246IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXNvdXJjZSBleHRlbmRzIEVudGl0eSB7XG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkgY2xvdWRGb3JtYXRpb25UeXBlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBJZiBzZXQsIHRoaXMgQ2xvdWRGb3JtYXRpb24gVHJhbnNmb3JtIGlzIHJlcXVpcmVkIGJ5IHRoZSByZXNvdXJjZVxuICAgKi9cbiAgY2xvdWRGb3JtYXRpb25UcmFuc2Zvcm0/OiBzdHJpbmc7XG4gIGRvY3VtZW50YXRpb24/OiBzdHJpbmc7XG4gIHByaW1hcnlJZGVudGlmaWVyPzogc3RyaW5nW107XG4gIHJlYWRvbmx5IHByb3BlcnRpZXM6IFJlc291cmNlUHJvcGVydGllcztcbiAgcmVhZG9ubHkgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgQXR0cmlidXRlPjtcbiAgcmVhZG9ubHkgdmFsaWRhdGlvbnM/OiB1bmtub3duO1xuICBpZGVudGlmaWVyPzogUmVzb3VyY2VJZGVudGlmaWVyO1xuICBpc1N0YXRlZnVsPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhZ2dhYmlsaXR5IG9mIHRoaXMgcmVzb3VyY2VcbiAgICpcbiAgICogVW5kZWZpbmVkIGlmIHRoZSByZXNvdXJjZSBpcyBub3QgdGFnZ2FibGUuXG4gICAqL1xuICB0YWdJbmZvcm1hdGlvbj86IFRhZ0luZm9ybWF0aW9uO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGNoYW5nZXMgdG8gdGhpcyByZXNvdXJjZSBuZWVkIHRvIGJlIHNjcnV0aW5pemVkXG4gICAqXG4gICAqIEBkZWZhdWx0IFJlc291cmNlU2NydXRpbnlUeXBlLk5PTkVcbiAgICovXG4gIHNjcnV0aW5pemFibGU/OiBSZXNvdXJjZVNjcnV0aW55VHlwZTtcblxuICAvKipcbiAgICogQWRkaXRpb25hbCBwYXRocyB0byBwcm9wZXJ0aWVzIHRoYXQgYWxzbyBjYXVzZSByZXBsYWNlbWVudC5cbiAgICpcbiAgICogVGhpcyBpcyB0byBpbmRpY2F0ZSB0aGF0IGNlcnRhaW4gcHJvcGVydHkgcGF0aHMgaW50byB0aGlzIHJlc291cmNlXG4gICAqIHdpbGwgY2F1c2UgcmVwbGFjZW1lbnQ7IG9ubHkgcmVwbGFjZW1lbnRzIHRoYXQgY2Fubm90IGJlIHJlcHJlc2VudGVkXG4gICAqIGJ5IHRhZ2dpbmcgdGhlIHByb3BlcnR5IGluIGEgdHlwZSBkZWZpbml0aW9uIHdpbGwgYmUgaW5jbHVkZWQgaGVyZVxuICAgKiAoZm9yIGV4YW1wbGUsIGJlY2F1c2UgdGhlIHRhZ2dlZCBwcm9wZXJ0eSB3b3VsZCBiZSBpbiBhIHByZWRlZmluZWRcbiAgICogdHlwZSBsaWtlIGB0YWdgKS5cbiAgICpcbiAgICogQWxsIHByb3BlcnRpZXMgaW4gdGhpcyBsaXN0IHNob3VsZCBiZSB0cmVhdGVkIGFzIGBjYXVzZXNSZXBsYWNlbWVudDogJ3llcydgLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtXG4gICAqL1xuICBhZGRpdGlvbmFsUmVwbGFjZW1lbnRQcm9wZXJ0aWVzPzogc3RyaW5nW11bXTtcbn1cblxuZXhwb3J0IHR5cGUgUmVzb3VyY2VQcm9wZXJ0aWVzID0gUmVjb3JkPHN0cmluZywgUHJvcGVydHk+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVEZWZpbml0aW9uIGV4dGVuZHMgRW50aXR5IHtcbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuICBkb2N1bWVudGF0aW9uPzogc3RyaW5nO1xuICByZWFkb25seSBwcm9wZXJ0aWVzOiBSZXNvdXJjZVByb3BlcnRpZXM7XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIHJlbmRlciB0aGlzIHR5cGUgZXZlbiBpZiBpdCBpcyB1bnVzZWQuXG4gICAqL1xuICBtdXN0UmVuZGVyRm9yQndDb21wYXQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BlcnR5IHtcbiAgLyoqXG4gICAqIERlc2NyaXB0aW9uIG9mIHRoZSBwcm9wZXJ0eVxuICAgKi9cbiAgZG9jdW1lbnRhdGlvbj86IHN0cmluZztcblxuICAvKipcbiAgICogSXMgdGhpcyBwcm9wZXJ0eSByZXF1aXJlZFxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVxdWlyZWQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB0eXBlIG9mIHRoaXMgcHJvcGVydHlcbiAgICovXG4gIHR5cGU6IFByb3BlcnR5VHlwZTtcblxuICAvKipcbiAgICogQW4gb3JkZXJlZCBsaXN0IG9mIHByZXZpb3VzIHR5cGVzIG9mIHRoaXMgcHJvcGVydHkgaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAqXG4gICAqIERvZXMgbm90IGluY2x1ZGUgdGhlIGN1cnJlbnQgdHlwZSwgdXNlIGB0eXBlYCBmb3IgdGhpcy5cbiAgICovXG4gIHByZXZpb3VzVHlwZXM/OiBQcm9wZXJ0eVR5cGVbXTtcblxuICAvKipcbiAgICogQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gdGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eVxuICAgKlxuICAgKiBUaGlzIHZhbHVlIGlzIG5vdCBkaXJlY3RseSBmdW5jdGlvbmFsOyBpdCBkZXNjcmliZXMgaG93IHRoZSB1bmRlcmx5aW5nIHJlc291cmNlXG4gICAqIHdpbGwgYmVoYXZlIGlmIHRoZSB2YWx1ZSBpcyBub3Qgc3BlY2lmaWVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIERlZmF1bHQgdW5rbm93blxuICAgKi9cbiAgZGVmYXVsdFZhbHVlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgcHJvcGVydHkgaXMgZGVwcmVjYXRlZFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vdCBkZXByZWNhdGVkXG4gICAqL1xuICBkZXByZWNhdGVkPzogRGVwcmVjYXRpb247XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgY2hhbmdlcyB0byB0aGlzIHByb3BlcnR5IG5lZWRzIHRvIGJlIHNjcnV0aW5pemVkIHNwZWNpYWxseVxuICAgKlxuICAgKiBAZGVmYXVsdCBQcm9wZXJ0eVNjcnV0aW55VHlwZS5OT05FXG4gICAqL1xuICBzY3J1dGluaXphYmxlPzogUHJvcGVydHlTY3J1dGlueVR5cGU7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGNvbnRhaW5pbmcgcmVzb3VyY2Ugd2lsbCBiZSByZXBsYWNlZCBpZiB0aGlzIHByb3BlcnR5IGlzIGNoYW5nZWRcbiAgICpcbiAgICogQGRlZmF1bHQgJ25vJ1xuICAgKi9cbiAgY2F1c2VzUmVwbGFjZW1lbnQ/OiAneWVzJyB8ICdubycgfCAnbWF5YmUnO1xufVxuXG5leHBvcnQgY2xhc3MgUmljaFR5cGVkRmllbGQge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGZpZWxkOiBQaWNrPFByb3BlcnR5LCAndHlwZScgfCAncHJldmlvdXNUeXBlcyc+KSB7XG4gICAgaWYgKGZpZWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgaXMgdW5kZWZpbmVkJyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHR5cGVzKCk6IFByb3BlcnR5VHlwZVtdIHtcbiAgICByZXR1cm4gWy4uLih0aGlzLmZpZWxkLnByZXZpb3VzVHlwZXMgPz8gW10pLCB0aGlzLmZpZWxkLnR5cGVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgdHlwZSBvZiB0aGlzIHByb3BlcnR5IHdpdGggYSBuZXcgdHlwZVxuICAgKlxuICAgKiBPbmx5IGlmIGl0J3Mgbm90IGluIHRoZSBzZXQgb2YgdHlwZXMgYWxyZWFkeS5cbiAgICovXG4gIHB1YmxpYyB1cGRhdGVUeXBlKHR5cGU6IFByb3BlcnR5VHlwZSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHJpY2hUeXBlID0gbmV3IFJpY2hQcm9wZXJ0eVR5cGUodHlwZSk7XG5cbiAgICAvLyBPbmx5IGFkZCB0aGlzIHR5cGUgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGl0LiBXZSBhcmUgb25seSBkb2luZyBjb21wYXJpc29ucyB3aGVyZSAnaW50ZWdlcicgYW5kICdudW1iZXInXG4gICAgLy8gYXJlIHRyZWF0ZWQgdGhlIHNhbWUsIGZvciBhbGwgb3RoZXIgdHlwZXMgd2UgbmVlZCBzdHJpY3QgZXF1YWxpdHkuIFdlIHVzZWQgdG8gdXNlICdhc3NpZ25hYmxlVG8nIGFzIGFcbiAgICAvLyBjb25kaXRpb24sIGJ1dCB0aGVzZSB0eXBlcyB3aWxsIGJlIHJlbmRlcmVkIGluIGJvdGggY28tIGFuZCBjb250cmF2YXJpYW50IHBvc2l0aW9ucywgYW5kIHNvIHdlIHJlYWxseSBjYW4ndFxuICAgIC8vIGRvIG11Y2ggYmV0dGVyIHRoYW4gZnVsbCBlcXVhbGl0eS5cbiAgICBpZiAodGhpcy50eXBlcygpLnNvbWUoKHQpID0+IHJpY2hUeXBlLmVxdWFscyh0KSkpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8sIHR5cGUgaXMgYWxyZWFkeSBpbiB0aGVyZS5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2U6IGlmIHRoZSBuZXcgdHlwZSBpcyBgc3RyaW5nYCBhbmQgdGhlIG9sZCB0eXBlIGlzIGBkYXRlLXRpbWVgLCB3ZSBhc3N1bWUgdGhpcyBpc1xuICAgIC8vIHRoZSBzYW1lIHR5cGUgYnV0IHdlIGRyb3BwZWQgc29tZSBmb3JtYXR0aW5nIGluZm9ybWF0aW9uLiBObyBuZWVkIHRvIG1ha2UgdGhpcyBhIHNlcGFyYXRlIHR5cGUuXG4gICAgaWYgKHR5cGUudHlwZSA9PT0gJ3N0cmluZycgJiYgdGhpcy50eXBlcygpLnNvbWUoKHQpID0+IHQudHlwZSA9PT0gJ2RhdGUtdGltZScpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmZpZWxkLnByZXZpb3VzVHlwZXMpIHtcbiAgICAgIHRoaXMuZmllbGQucHJldmlvdXNUeXBlcyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmZpZWxkLnByZXZpb3VzVHlwZXMucHVzaCh0aGlzLmZpZWxkLnR5cGUpO1xuICAgIHRoaXMuZmllbGQudHlwZSA9IHR5cGU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJpY2hQcm9wZXJ0eSBleHRlbmRzIFJpY2hUeXBlZEZpZWxkIHtcbiAgY29uc3RydWN0b3IocHJvcGVydHk6IFByb3BlcnR5KSB7XG4gICAgc3VwZXIocHJvcGVydHkpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSaWNoQXR0cmlidXRlIGV4dGVuZHMgUmljaFR5cGVkRmllbGQge1xuICBjb25zdHJ1Y3RvcihhdHRyOiBBdHRyaWJ1dGUpIHtcbiAgICBzdXBlcihhdHRyKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF0dHJpYnV0ZSB7XG4gIGRvY3VtZW50YXRpb24/OiBzdHJpbmc7XG4gIHR5cGU6IFByb3BlcnR5VHlwZTtcbiAgLyoqXG4gICAqIEFuIG9yZGVyZWQgbGlzdCBvZiBwcmV2aW91cyB0eXBlcyBvZiB0aGlzIHByb3BlcnR5IGluIGFzY2VuZGluZyBvcmRlclxuICAgKlxuICAgKiBEb2VzIG5vdCBpbmNsdWRlIHRoZSBjdXJyZW50IHR5cGUsIHVzZSBgdHlwZWAgZm9yIHRoaXMuXG4gICAqL1xuICBwcmV2aW91c1R5cGVzPzogUHJvcGVydHlUeXBlW107XG59XG5cbmV4cG9ydCBlbnVtIERlcHJlY2F0aW9uIHtcbiAgLyoqXG4gICAqIE5vdCBkZXByZWNhdGVkXG4gICAqL1xuICBOT05FID0gJ05PTkUnLFxuXG4gIC8qKlxuICAgKiBXYXJuIGFib3V0IHVzZVxuICAgKi9cbiAgV0FSTiA9ICdXQVJOJyxcblxuICAvKipcbiAgICogRG8gbm90IGVtaXQgdGhlIHZhbHVlIGF0IGFsbFxuICAgKlxuICAgKiAoSGFuZGxlIHByb3BlcnRpZXMgdGhhdCB3ZXJlIGluY29ycmVjdGx5IGFkZGVkIHRvIHRoZSBzcGVjKVxuICAgKi9cbiAgSUdOT1JFID0gJ0lHTk9SRScsXG59XG5cbmV4cG9ydCB0eXBlIFByb3BlcnR5VHlwZSA9XG4gIHwgUHJpbWl0aXZlVHlwZVxuICB8IERlZmluaXRpb25SZWZlcmVuY2VcbiAgfCBCdWlsdGluVGFnVHlwZVxuICB8IEFycmF5VHlwZTxQcm9wZXJ0eVR5cGU+XG4gIHwgTWFwVHlwZTxQcm9wZXJ0eVR5cGU+XG4gIHwgVHlwZVVuaW9uPFByb3BlcnR5VHlwZT47XG5cbmV4cG9ydCB0eXBlIFByaW1pdGl2ZVR5cGUgPVxuICB8IFN0cmluZ1R5cGVcbiAgfCBOdW1iZXJUeXBlXG4gIHwgSW50ZWdlclR5cGVcbiAgfCBCb29sZWFuVHlwZVxuICB8IEpzb25UeXBlXG4gIHwgRGF0ZVRpbWVUeXBlXG4gIHwgTnVsbFR5cGVcbiAgfCBCdWlsdGluVGFnVHlwZTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29sbGVjdGlvblR5cGUoeDogUHJvcGVydHlUeXBlKTogeCBpcyBBcnJheVR5cGU8YW55PiB8IE1hcFR5cGU8YW55PiB7XG4gIHJldHVybiB4LnR5cGUgPT09ICdhcnJheScgfHwgeC50eXBlID09PSAnbWFwJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWdJbmZvcm1hdGlvbiB7XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGhvbGRzIHRoZSB0YWdzXG4gICAqL1xuICByZWFkb25seSB0YWdQcm9wZXJ0eU5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVXNlZCB0byBpbnN0cnVjdCBjZGsuVGFnTWFuYWdlciBob3cgdG8gaGFuZGxlIHRhZ3NcbiAgICovXG4gIHJlYWRvbmx5IHZhcmlhbnQ6IFRhZ1ZhcmlhbnQ7XG59XG5cbmV4cG9ydCB0eXBlIFRhZ1ZhcmlhbnQgPSAnc3RhbmRhcmQnIHwgJ2FzZycgfCAnbWFwJztcblxuZXhwb3J0IGludGVyZmFjZSBTdHJpbmdUeXBlIHtcbiAgcmVhZG9ubHkgdHlwZTogJ3N0cmluZyc7XG59XG5leHBvcnQgaW50ZXJmYWNlIEJ1aWx0aW5UYWdUeXBlIHtcbiAgcmVhZG9ubHkgdHlwZTogJ3RhZyc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTnVtYmVyVHlwZSB7XG4gIHJlYWRvbmx5IHR5cGU6ICdudW1iZXInO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEludGVnZXJUeXBlIHtcbiAgcmVhZG9ubHkgdHlwZTogJ2ludGVnZXInO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJvb2xlYW5UeXBlIHtcbiAgcmVhZG9ubHkgdHlwZTogJ2Jvb2xlYW4nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEpzb25UeXBlIHtcbiAgcmVhZG9ubHkgdHlwZTogJ2pzb24nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE51bGxUeXBlIHtcbiAgcmVhZG9ubHkgdHlwZTogJ251bGwnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVUaW1lVHlwZSB7XG4gIHJlYWRvbmx5IHR5cGU6ICdkYXRlLXRpbWUnO1xufVxuXG4vKipcbiAqIFRoZSBcImxlZ2FjeVwiIHRhZyB0eXBlICh1c2VkIGluIHRoZSBvbGQgcmVzb3VyY2Ugc3BlYylcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCdWlsdGluVGFnVHlwZSB7XG4gIHJlYWRvbmx5IHR5cGU6ICd0YWcnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlZmluaXRpb25SZWZlcmVuY2Uge1xuICByZWFkb25seSB0eXBlOiAncmVmJztcbiAgcmVhZG9ubHkgcmVmZXJlbmNlOiBSZWZlcmVuY2U8VHlwZURlZmluaXRpb24+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFycmF5VHlwZTxFPiB7XG4gIHJlYWRvbmx5IHR5cGU6ICdhcnJheSc7XG4gIHJlYWRvbmx5IGVsZW1lbnQ6IEU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFwVHlwZTxFPiB7XG4gIHJlYWRvbmx5IHR5cGU6ICdtYXAnO1xuICByZWFkb25seSBlbGVtZW50OiBFO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVVbmlvbjxFPiB7XG4gIHJlYWRvbmx5IHR5cGU6ICd1bmlvbic7XG4gIHJlYWRvbmx5IHR5cGVzOiBFW107XG59XG5cbmV4cG9ydCB0eXBlIEhhc1Jlc291cmNlID0gUmVsYXRpb25zaGlwPFNlcnZpY2UsIFJlc291cmNlPjtcbmV4cG9ydCB0eXBlIFJlZ2lvbkhhc1Jlc291cmNlID0gUmVsYXRpb25zaGlwPFJlZ2lvbiwgUmVzb3VyY2U+O1xuZXhwb3J0IHR5cGUgUmVnaW9uSGFzU2VydmljZSA9IFJlbGF0aW9uc2hpcDxSZWdpb24sIFNlcnZpY2U+O1xuZXhwb3J0IHR5cGUgUmVzb3VyY2VEb2MgPSBSZWxhdGlvbnNoaXA8UmVzb3VyY2UsIERvY3VtZW50YXRpb24+O1xuXG5leHBvcnQgdHlwZSBTZXJ2aWNlSW5SZWdpb24gPSBSZWxhdGlvbnNoaXA8UmVnaW9uLCBTZXJ2aWNlPjtcbmV4cG9ydCB0eXBlIFJlc291cmNlSW5SZWdpb24gPSBSZWxhdGlvbnNoaXA8UmVnaW9uLCBSZXNvdXJjZT47XG5cbmV4cG9ydCB0eXBlIFVzZXNUeXBlID0gUmVsYXRpb25zaGlwPFJlc291cmNlLCBUeXBlRGVmaW5pdGlvbj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VJZGVudGlmaWVyIGV4dGVuZHMgRW50aXR5IHtcbiAgcmVhZG9ubHkgYXJuVGVtcGxhdGU/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IHByaW1hcnlJZGVudGlmaWVyPzogc3RyaW5nW107XG59XG5cbi8qKlxuICogTWFyayBhIHJlc291cmNlIGFzIGEgcmVzb3VyY2UgdGhhdCBuZWVkcyBhZGRpdGlvbmFsIHNjcnV0aXkgd2hlbiBhZGRlZCwgcmVtb3ZlZCBvciBjaGFuZ2VkXG4gKlxuICogVXNlZCB0byBtYXJrIHJlc291cmNlcyB0aGF0IHJlcHJlc2VudCBzZWN1cml0eSBwb2xpY2llcy5cbiAqL1xuZXhwb3J0IGVudW0gUmVzb3VyY2VTY3J1dGlueVR5cGUge1xuICAvKipcbiAgICogTm8gYWRkaXRpb25hbCBzY3J1dGlueVxuICAgKi9cbiAgTm9uZSA9ICdOb25lJyxcblxuICAvKipcbiAgICogQW4gZXh0ZXJuYWxseSBhdHRhY2hlZCBwb2xpY3kgZG9jdW1lbnQgdG8gYSByZXNvdXJjZVxuICAgKlxuICAgKiAoQ29tbW9uIGZvciBTUVMsIFNOUywgUzMsIC4uLilcbiAgICovXG4gIFJlc291cmNlUG9saWN5UmVzb3VyY2UgPSAnUmVzb3VyY2VQb2xpY3lSZXNvdXJjZScsXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYW4gSUFNIHBvbGljeSBvbiBhbiBpZGVudGl0eSByZXNvdXJjZVxuICAgKlxuICAgKiAoQmFzaWNhbGx5IHNheWluZzogdGhpcyBpcyBBV1M6OklBTTo6UG9saWN5KVxuICAgKi9cbiAgSWRlbnRpdHlQb2xpY3lSZXNvdXJjZSA9ICdJZGVudGl0eVBvbGljeVJlc291cmNlJyxcblxuICAvKipcbiAgICogVGhpcyBpcyBhIExhbWJkYSBQZXJtaXNzaW9uIHBvbGljeVxuICAgKi9cbiAgTGFtYmRhUGVybWlzc2lvbiA9ICdMYW1iZGFQZXJtaXNzaW9uJyxcblxuICAvKipcbiAgICogQW4gaW5ncmVzcyBydWxlIG9iamVjdFxuICAgKi9cbiAgSW5ncmVzc1J1bGVSZXNvdXJjZSA9ICdJbmdyZXNzUnVsZVJlc291cmNlJyxcblxuICAvKipcbiAgICogQSBzZXQgb2YgZWdyZXNzIHJ1bGVzXG4gICAqL1xuICBFZ3Jlc3NSdWxlUmVzb3VyY2UgPSAnRWdyZXNzUnVsZVJlc291cmNlJyxcblxuICAvKipcbiAgICogQVdTOjpTU086OkFzc2lnbm1lbnRcbiAgICpcbiAgICogSUFNIElkZW50aXR5IENlbnRlciAoZm9ybWVybHkga25vd24gYXMgU1NPKVxuICAgKi9cbiAgU3NvQXNzaWdubWVudFJlc291cmNlID0gJ1Nzb0Fzc2lnbm1lbnRSZXNvdXJjZScsXG5cbiAgLyoqXG4gICAqIEFXUzo6U1NPOjpJbnN0YW5jZUFjY2Vzc0NvbnRyb2xBdHRyaWJ1dGVDb25maWd1cmF0aW9uXG4gICAqXG4gICAqIElBTSBJZGVudGl0eSBDZW50ZXIgKGZvcm1lcmx5IGtub3duIGFzIFNTTylcbiAgICovXG4gIFNzb0luc3RhbmNlQUNBQ29uZmlnUmVzb3VyY2UgPSAnU3NvSW5zdGFuY2VBQ0FDb25maWdSZXNvdXJjZScsXG5cbiAgLyoqXG4gICAqIEFXUzo6U1NPOjpQZXJtaXNzaW9uU2V0XG4gICAqXG4gICAqIElBTSBJZGVudGl0eSBDZW50ZXIgKGZvcm1lcmx5IGtub3duIGFzIFNTTylcbiAgICovXG4gIFNzb1Blcm1pc3Npb25TZXQgPSAnU3NvUGVybWlzc2lvblNldCcsXG59XG5cbi8qKlxuICogTWFyayBhIHByb3BlcnR5IGFzIGEgcHJvcGVydHkgdGhhdCBuZWVkcyBhZGRpdGlvbmFsIHNjcnV0aW55IHdoZW4gaXQgY2hhbmdlc1xuICpcbiAqIFVzZWQgdG8gbWFyayBzZW5zaXRpdmUgcHJvcGVydGllcyB0aGF0IGhhdmUgc2VjdXJpdHktcmVsYXRlZCBpbXBsaWNhdGlvbnMuXG4gKi9cbmV4cG9ydCBlbnVtIFByb3BlcnR5U2NydXRpbnlUeXBlIHtcbiAgLyoqXG4gICAqIE5vIGFkZGl0aW9uYWwgc2NydXRpbnlcbiAgICovXG4gIE5vbmUgPSAnTm9uZScsXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYW4gSUFNIHBvbGljeSBkaXJlY3RseSBvbiBhIHJlc291cmNlXG4gICAqL1xuICBJbmxpbmVSZXNvdXJjZVBvbGljeSA9ICdJbmxpbmVSZXNvdXJjZVBvbGljeScsXG5cbiAgLyoqXG4gICAqIEVpdGhlciBhbiBBc3N1bWVSb2xlUG9saWN5RG9jdW1lbnQgb3IgYSBkaWN0aW9uYXJ5IG9mIHBvbGljeSBkb2N1bWVudHNcbiAgICovXG4gIElubGluZUlkZW50aXR5UG9saWNpZXMgPSAnSW5saW5lSWRlbnRpdHlQb2xpY2llcycsXG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBtYW5hZ2VkIHBvbGljaWVzIChvbiBhbiBpZGVudGl0eSByZXNvdXJjZSlcbiAgICovXG4gIE1hbmFnZWRQb2xpY2llcyA9ICdNYW5hZ2VkUG9saWNpZXMnLFxuXG4gIC8qKlxuICAgKiBBIHNldCBvZiBpbmdyZXNzIHJ1bGVzIChvbiBhIHNlY3VyaXR5IGdyb3VwKVxuICAgKi9cbiAgSW5ncmVzc1J1bGVzID0gJ0luZ3Jlc3NSdWxlcycsXG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIGVncmVzcyBydWxlcyAob24gYSBzZWN1cml0eSBncm91cClcbiAgICovXG4gIEVncmVzc1J1bGVzID0gJ0VncmVzc1J1bGVzJyxcbn1cblxuZXhwb3J0IGNsYXNzIFJpY2hQcm9wZXJ0eVR5cGUge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHR5cGU6IFByb3BlcnR5VHlwZSkge31cblxuICBwdWJsaWMgZXF1YWxzKHJoczogUHJvcGVydHlUeXBlKTogYm9vbGVhbiB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUudHlwZSkge1xuICAgICAgY2FzZSAnaW50ZWdlcic6XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUtdGltZSc6XG4gICAgICBjYXNlICdqc29uJzpcbiAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd0YWcnOlxuICAgICAgICByZXR1cm4gcmhzLnR5cGUgPT09IHRoaXMudHlwZS50eXBlO1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnbWFwJzpcbiAgICAgICAgcmV0dXJuIHJocy50eXBlID09PSB0aGlzLnR5cGUudHlwZSAmJiBuZXcgUmljaFByb3BlcnR5VHlwZSh0aGlzLnR5cGUuZWxlbWVudCkuZXF1YWxzKHJocy5lbGVtZW50KTtcbiAgICAgIGNhc2UgJ3JlZic6XG4gICAgICAgIHJldHVybiByaHMudHlwZSA9PT0gJ3JlZicgJiYgdGhpcy50eXBlLnJlZmVyZW5jZS4kcmVmID09PSByaHMucmVmZXJlbmNlLiRyZWY7XG4gICAgICBjYXNlICd1bmlvbic6XG4gICAgICAgIGNvbnN0IGxoc0tleSA9IHRoaXMuc29ydEtleSgpO1xuICAgICAgICBjb25zdCByaHNLZXkgPSBuZXcgUmljaFByb3BlcnR5VHlwZShyaHMpLnNvcnRLZXkoKTtcbiAgICAgICAgcmV0dXJuIGxoc0tleS5sZW5ndGggPT09IHJoc0tleS5sZW5ndGggJiYgbGhzS2V5LmV2ZXJ5KChsLCBpKSA9PiBsID09PSByaHNLZXlbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjdXJyZW50IHR5cGUgaXMgSmF2YVNjcmlwdC1lcXVhbCB0byB0aGUgUkhTIHR5cGVcbiAgICpcbiAgICogU2FtZSBhcyBub3JtYWwgZXF1YWxpdHksIGJ1dCBjb25zaWRlciBgaW50ZWdlcmAgYW5kIGBudW1iZXJgIHRoZSBzYW1lIHR5cGVzLlxuICAgKi9cbiAgcHVibGljIGphdmFzY3JpcHRFcXVhbHMocmhzOiBQcm9wZXJ0eVR5cGUpOiBib29sZWFuIHtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZS50eXBlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnaW50ZWdlcic6XG4gICAgICAgIC8vIFdpZGVuaW5nXG4gICAgICAgIHJldHVybiByaHMudHlwZSA9PT0gJ2ludGVnZXInIHx8IHJocy50eXBlID09PSAnbnVtYmVyJztcblxuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnbWFwJzpcbiAgICAgICAgcmV0dXJuIHJocy50eXBlID09PSB0aGlzLnR5cGUudHlwZSAmJiBuZXcgUmljaFByb3BlcnR5VHlwZSh0aGlzLnR5cGUuZWxlbWVudCkuamF2YXNjcmlwdEVxdWFscyhyaHMuZWxlbWVudCk7XG5cbiAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgaWYgKHJocy50eXBlICE9PSAndW5pb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV2ZXJ5IHR5cGUgaW4gdGhpcyB1bmlvbiBuZWVkcyB0byBiZSBlcXVhbCBvbmUgdHlwZSBpbiBSSFNcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS50eXBlcy5ldmVyeSgodDEpID0+IHJocy50eXBlcy5zb21lKCh0MikgPT4gbmV3IFJpY2hQcm9wZXJ0eVR5cGUodDEpLmphdmFzY3JpcHRFcXVhbHModDIpKSk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEZvciBhbnl0aGluZyBlbHNlLCBuZWVkIHN0cmljdCBlcXVhbGl0eVxuICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMocmhzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgY3VycmVudCB0eXBlIGlzIGFzc2lnbmFibGUgdG8gdGhlIFJIUyB0eXBlLlxuICAgKlxuICAgKiBUaGlzIGlzIG1lYW5zIGV2ZXJ5IHR5cGUgbWVtYmVyIG9mIHRoZSBMSFMgbXVzdCBiZSBwcmVzZW50IGluIHRoZSBSSFMgdHlwZVxuICAgKi9cbiAgcHVibGljIGFzc2lnbmFibGVUbyhyaHM6IFByb3BlcnR5VHlwZSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGV4dHJhY3RNZW1iZXJzID0gKHR5cGU6IFByb3BlcnR5VHlwZSk6IFByb3BlcnR5VHlwZVtdID0+ICh0eXBlLnR5cGUgPT0gJ3VuaW9uJyA/IHR5cGUudHlwZXMgOiBbdHlwZV0pO1xuICAgIGNvbnN0IGFzUmljaFR5cGUgPSAodHlwZTogUHJvcGVydHlUeXBlKTogUmljaFByb3BlcnR5VHlwZSA9PiBuZXcgUmljaFByb3BlcnR5VHlwZSh0eXBlKTtcblxuICAgIGNvbnN0IHJoc01lbWJlcnMgPSBleHRyYWN0TWVtYmVycyhyaHMpO1xuICAgIGZvciAoY29uc3QgbGhzTWVtYmVyIG9mIGV4dHJhY3RNZW1iZXJzKHRoaXMudHlwZSkubWFwKGFzUmljaFR5cGUpKSB7XG4gICAgICBpZiAoIXJoc01lbWJlcnMuc29tZSgodHlwZSkgPT4gbGhzTWVtYmVyLmVxdWFscyh0eXBlKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHZlcnNpb24gb2YgdGhpcyB0eXBlLCBidXQgd2l0aCBhbGwgdHlwZSB1bmlvbnMgaW4gYSByZWd1bGFyaXplZCBvcmRlclxuICAgKi9cbiAgcHVibGljIG5vcm1hbGl6ZShkYjogU3BlY0RhdGFiYXNlKTogUmljaFByb3BlcnR5VHlwZSB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUudHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnbWFwJzpcbiAgICAgICAgcmV0dXJuIG5ldyBSaWNoUHJvcGVydHlUeXBlKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUudHlwZSxcbiAgICAgICAgICBlbGVtZW50OiBuZXcgUmljaFByb3BlcnR5VHlwZSh0aGlzLnR5cGUuZWxlbWVudCkubm9ybWFsaXplKGRiKS50eXBlLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgY29uc3QgdHlwZXMgPSB0aGlzLnR5cGUudHlwZXNcbiAgICAgICAgICAubWFwKCh0KSA9PiBuZXcgUmljaFByb3BlcnR5VHlwZSh0KS5ub3JtYWxpemUoZGIpKVxuICAgICAgICAgIC5tYXAoKHQpID0+IFt0LCB0LnNvcnRLZXkoZGIpXSBhcyBjb25zdCk7XG4gICAgICAgIHR5cGVzLnNvcnQoc29ydEtleUNvbXBhcmF0b3IoKFtfLCBzb3J0S2V5XSkgPT4gc29ydEtleSkpO1xuICAgICAgICByZXR1cm4gbmV3IFJpY2hQcm9wZXJ0eVR5cGUoe1xuICAgICAgICAgIHR5cGU6ICd1bmlvbicsXG4gICAgICAgICAgdHlwZXM6IHR5cGVzLm1hcCgoW3QsIF9dKSA9PiB0LnR5cGUpLFxuICAgICAgICB9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdHJpbmdpZnkoZGI6IFNwZWNEYXRhYmFzZSwgd2l0aElkID0gdHJ1ZSk6IHN0cmluZyB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUudHlwZSkge1xuICAgICAgY2FzZSAnaW50ZWdlcic6XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUtdGltZSc6XG4gICAgICBjYXNlICdqc29uJzpcbiAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd0YWcnOlxuICAgICAgICByZXR1cm4gdGhpcy50eXBlLnR5cGU7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgIHJldHVybiBgQXJyYXk8JHtuZXcgUmljaFByb3BlcnR5VHlwZSh0aGlzLnR5cGUuZWxlbWVudCkuc3RyaW5naWZ5KGRiLCB3aXRoSWQpfT5gO1xuICAgICAgY2FzZSAnbWFwJzpcbiAgICAgICAgcmV0dXJuIGBNYXA8c3RyaW5nLCAke25ldyBSaWNoUHJvcGVydHlUeXBlKHRoaXMudHlwZS5lbGVtZW50KS5zdHJpbmdpZnkoZGIsIHdpdGhJZCl9PmA7XG4gICAgICBjYXNlICdyZWYnOlxuICAgICAgICBjb25zdCB0eXBlID0gZGIuZ2V0KCd0eXBlRGVmaW5pdGlvbicsIHRoaXMudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICByZXR1cm4gd2l0aElkID8gYCR7dHlwZS5uYW1lfSgke3RoaXMudHlwZS5yZWZlcmVuY2UuJHJlZn0pYCA6IHR5cGUubmFtZTtcbiAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS50eXBlcy5tYXAoKHQpID0+IG5ldyBSaWNoUHJvcGVydHlUeXBlKHQpLnN0cmluZ2lmeShkYiwgd2l0aElkKSkuam9pbignIHwgJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHNvcnRhYmxlIGtleSBiYXNlZCBvbiB0aGlzIHR5cGVcbiAgICpcbiAgICogSWYgYSBkYXRhYmFzZSBpcyBnaXZlbiwgdHlwZSBkZWZpbml0aW9ucyB3aWxsIGJlIHNvcnRlZCBiYXNlZCBvbiB0eXBlIG5hbWUsXG4gICAqIG90aGVyd2lzZSBvbiBpZGVudGlmaWVyXG4gICAqL1xuICBwdWJsaWMgc29ydEtleShkYj86IFNwZWNEYXRhYmFzZSk6IHN0cmluZ1tdIHtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZS50eXBlKSB7XG4gICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZS10aW1lJzpcbiAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgIHJldHVybiBbJzAnLCB0aGlzLnR5cGUudHlwZV07XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdtYXAnOlxuICAgICAgICByZXR1cm4gWycxJywgdGhpcy50eXBlLnR5cGUsIC4uLm5ldyBSaWNoUHJvcGVydHlUeXBlKHRoaXMudHlwZS5lbGVtZW50KS5zb3J0S2V5KGRiKV07XG4gICAgICBjYXNlICdyZWYnOlxuICAgICAgICByZXR1cm4gWycyJywgdGhpcy50eXBlLnR5cGUsIGRiPy5nZXQoJ3R5cGVEZWZpbml0aW9uJywgdGhpcy50eXBlLnJlZmVyZW5jZSk/Lm5hbWUgPz8gdGhpcy50eXBlLnJlZmVyZW5jZS4kcmVmXTtcbiAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgY29uc3QgdHlwZUtleXMgPSB0aGlzLnR5cGUudHlwZXMubWFwKCh0KSA9PiBuZXcgUmljaFByb3BlcnR5VHlwZSh0KS5zb3J0S2V5KGRiKSk7XG4gICAgICAgIHR5cGVLZXlzLnNvcnQoc29ydEtleUNvbXBhcmF0b3IoKHgpID0+IHgpKTtcbiAgICAgICAgcmV0dXJuIFsnMycsIHRoaXMudHlwZS50eXBlLCAuLi50eXBlS2V5cy5mbGF0TWFwKCh4KSA9PiB4KV07XG4gICAgfVxuICB9XG59XG4iXX0=